{
    "docs": [
        {
            "location": "/", 
            "text": "Burlap - configuration management designed for simplicity and speed\n\n\n \n \n\n\nOverview\n\n\nBurlap is a \nconfiguration management\n\ntool and framework for deploying software to servers.\n\n\nIt's written in Python and is built ontop of \nFabric\n to run commands remotely over SSH.\n\n\nUnlike \nChef\n or \nAnsible\n that target large \"web-scale\" platforms at the expense of great complexity, Burlap targets small to medium-scale platforms and keeps its configuration simple.\n\n\nMuch of the code is also heavily influenced by \nFabtools\n, another Fabric-based toolkit.\n\n\nInstallation\n\n\nInstall the package via pip with:\n\n\npip install burlap\n\n\n\nUsage\n\n\n\n\n\n\nCD to a directory on your computer where you want to start your project and then run:\n\n\nburlap skel --name=\n\n\n\n\n\n\nThis will create a structure like:\n\n\nproject root\n\n\u251c\u2500\u2500 roles\n|   \u251c\u2500\u2500 all\n|   |   \u251c\u2500\u2500 templates\n|   |   \u251c\u2500\u2500 settings.yaml\n|   |   \u251c\u2500\u2500 pip-requirements.txt\n|   |   \u2514\u2500\u2500 \napt|yum\n-requirements.txt\n|   |\n|   \u251c\u2500\u2500 dev\n|   |   \u251c\u2500\u2500 templates\n|   |   \u2514\u2500\u2500 settings.yaml\n|   |\n|   \u2514\u2500\u2500 prod\n|       \u251c\u2500\u2500 templates\n|       \u2514\u2500\u2500 settings.yaml\n|\n\u251c\u2500\u2500 src\n|   \u251c\u2500\u2500 \nproject name\n\n|   \u2514\u2500\u2500 manage.py\n|\n\u2514\u2500\u2500 fabfile.py\n\n\n\n\n\n\n\nNow add the roles appropriate for your application. Common roles are development and production, e.g.\n\n\nburlap add role prod dev\n\n\n\n\n\n\nCreate your application code and test with Django's dev server.\n\n\n\n\n\n\nPrepare remote host for deployment.\n\n\n\n\n\n\nAllocate your production environment by setting up the physical server\nor creating a VPS.\n\n\nPopulate your settings.yaml. At minimum it would have hosts, key_filename,\nand user.\n\n\nhosts: [myserver.mydomain.com]\nuser: sys-user\nkey_filename: roles/prod/mydomain.pem\n\n\n\nIf you need to generate pub/pem files for passwordless SSH access, run:\n\n\nfab prod user.generate_keys\n\n\n\nEnsure the filename of the *.pem file matches the key_filename in your\nsettings.yaml.\n\n\nIf you just created a fresh server and have password SSH access and need\nto configure passwordless access, run:\n\n\nfab prod user.passwordless:username=\nusername\n,pubkey=\npath/to/yourdomain.pub\n\n\n\n\nConfirm you have passwordless access by running:\n\n\nfab prod shell\n\n\n\nIf you have an active shell prompt on the remote host and weren't prompted for\na password, you're ready to deploy.\n\n\n\n\n\n\nDeploy your code.\n\n\nfab prod tarball.create tarball.deploy\n\n\n\n\n\n\nPrepare your PIP cache.\n\n\n\n\n\n\nList all your Python packages in pip-requirements.txt and then run:\n\n\nfab prod pip.update\n\n\n\nThis will download, but not install, all your packages into a local cache.\nWe do this to prevent network latency or timeouts from interferring with our\ndeployment. Few things are more frustrating then waiting for 50 packages to\ninstall, only for the 50th to fail and torpedo our entire deployment.\n\n\nNote, if you have multiple roles you're deploying to, you can update them all\nin parallel by running this command for each role in separate terminals.\nThis can save quite a bit of time if you have many packages.\n\n\n\n\n\n\nInstall packages.\n\n\nfab prod pip.install\n\n\n\n\n\n\nThis will rsync all your cached packages up to the host, create a virtual\nenvironment and install the packages.\n\n\n\n\nCheck for package updates.\n\n\n\n\nDetecting updated packages is easy:\n\n\nfab prod pip.check_for_updates\n\n\n\nexample output:\n\n\nChecking requirement 83 of 83... \n===========================================================================\nThe following packages have updated versions available:\npackage,       installed_version, most_recent_version  \nDjango,        1.5.5,             1.6.2                \nFeinCMS,       1.7.4,             1.9.3                \nbilliard,      3.3.0.13,          3.3.0.16             \ncelery,        3.1.1,             3.1.9                \ndjango-celery, 3.1.1,             3.1.9                \nkombu,         3.0.8,             3.0.12               \nreportlab,     2.2,               3.0                  \n---------------------------------------------------------------------------\n7 packages have updates\n\n\n\nUsing this, you can review each package, determine which should be\nupdated in your pip-requirements.txt and installed via pip.install.\n\n\nDevelopment\n\n\nTo run tests:\n\n\n[tox](http://tox.readthedocs.org/en/latest/)\n\ntox -e py27 -- -s burlap/tests/test_project.py::test_project\n\n\n\nTo run the \ndocumentation server\n locally:\n\n\nmkdocs serve -a :9999\n\n\n\nTo \ndeploy documentation\n, run:\n\n\nmkdocs gh-deploy --clean\n\n\n\nTo build and deploy a versioned package to PyPI, verify \nall unittests are passing\n, and then run:\n\n\npython setup.py sdist\npython setup.py sdist upload", 
            "title": "Home"
        }, 
        {
            "location": "/#burlap-configuration-management-designed-for-simplicity-and-speed", 
            "text": "", 
            "title": "Burlap - configuration management designed for simplicity and speed"
        }, 
        {
            "location": "/#overview", 
            "text": "Burlap is a  configuration management \ntool and framework for deploying software to servers.  It's written in Python and is built ontop of  Fabric  to run commands remotely over SSH.  Unlike  Chef  or  Ansible  that target large \"web-scale\" platforms at the expense of great complexity, Burlap targets small to medium-scale platforms and keeps its configuration simple.  Much of the code is also heavily influenced by  Fabtools , another Fabric-based toolkit.", 
            "title": "Overview"
        }, 
        {
            "location": "/#installation", 
            "text": "Install the package via pip with:  pip install burlap", 
            "title": "Installation"
        }, 
        {
            "location": "/#usage", 
            "text": "CD to a directory on your computer where you want to start your project and then run:  burlap skel --name=    This will create a structure like:  project root \n\u251c\u2500\u2500 roles\n|   \u251c\u2500\u2500 all\n|   |   \u251c\u2500\u2500 templates\n|   |   \u251c\u2500\u2500 settings.yaml\n|   |   \u251c\u2500\u2500 pip-requirements.txt\n|   |   \u2514\u2500\u2500  apt|yum -requirements.txt\n|   |\n|   \u251c\u2500\u2500 dev\n|   |   \u251c\u2500\u2500 templates\n|   |   \u2514\u2500\u2500 settings.yaml\n|   |\n|   \u2514\u2500\u2500 prod\n|       \u251c\u2500\u2500 templates\n|       \u2514\u2500\u2500 settings.yaml\n|\n\u251c\u2500\u2500 src\n|   \u251c\u2500\u2500  project name \n|   \u2514\u2500\u2500 manage.py\n|\n\u2514\u2500\u2500 fabfile.py    Now add the roles appropriate for your application. Common roles are development and production, e.g.  burlap add role prod dev    Create your application code and test with Django's dev server.    Prepare remote host for deployment.    Allocate your production environment by setting up the physical server\nor creating a VPS.  Populate your settings.yaml. At minimum it would have hosts, key_filename,\nand user.  hosts: [myserver.mydomain.com]\nuser: sys-user\nkey_filename: roles/prod/mydomain.pem  If you need to generate pub/pem files for passwordless SSH access, run:  fab prod user.generate_keys  Ensure the filename of the *.pem file matches the key_filename in your\nsettings.yaml.  If you just created a fresh server and have password SSH access and need\nto configure passwordless access, run:  fab prod user.passwordless:username= username ,pubkey= path/to/yourdomain.pub   Confirm you have passwordless access by running:  fab prod shell  If you have an active shell prompt on the remote host and weren't prompted for\na password, you're ready to deploy.    Deploy your code.  fab prod tarball.create tarball.deploy    Prepare your PIP cache.    List all your Python packages in pip-requirements.txt and then run:  fab prod pip.update  This will download, but not install, all your packages into a local cache.\nWe do this to prevent network latency or timeouts from interferring with our\ndeployment. Few things are more frustrating then waiting for 50 packages to\ninstall, only for the 50th to fail and torpedo our entire deployment.  Note, if you have multiple roles you're deploying to, you can update them all\nin parallel by running this command for each role in separate terminals.\nThis can save quite a bit of time if you have many packages.    Install packages.  fab prod pip.install    This will rsync all your cached packages up to the host, create a virtual\nenvironment and install the packages.   Check for package updates.   Detecting updated packages is easy:  fab prod pip.check_for_updates  example output:  Checking requirement 83 of 83... \n===========================================================================\nThe following packages have updated versions available:\npackage,       installed_version, most_recent_version  \nDjango,        1.5.5,             1.6.2                \nFeinCMS,       1.7.4,             1.9.3                \nbilliard,      3.3.0.13,          3.3.0.16             \ncelery,        3.1.1,             3.1.9                \ndjango-celery, 3.1.1,             3.1.9                \nkombu,         3.0.8,             3.0.12               \nreportlab,     2.2,               3.0                  \n---------------------------------------------------------------------------\n7 packages have updates  Using this, you can review each package, determine which should be\nupdated in your pip-requirements.txt and installed via pip.install.", 
            "title": "Usage"
        }, 
        {
            "location": "/#development", 
            "text": "To run tests:  [tox](http://tox.readthedocs.org/en/latest/)\n\ntox -e py27 -- -s burlap/tests/test_project.py::test_project  To run the  documentation server  locally:  mkdocs serve -a :9999  To  deploy documentation , run:  mkdocs gh-deploy --clean  To build and deploy a versioned package to PyPI, verify  all unittests are passing , and then run:  python setup.py sdist\npython setup.py sdist upload", 
            "title": "Development"
        }, 
        {
            "location": "/tests/", 
            "text": "Tests\n\n\nUsing tox\n\n\nThe preferred way to run tests is to use \ntox \nhttps://tox.readthedocs.org/en/latest/\n_.\nIt will take care of everything and run the tests on all supported Python\nversions (each in its own virtualenv) and all target operating systems :\n\n\n$ tox\n\n\n\nTox will also build the Sphinx documentation, so it will tell you about any\nreStructuredText syntax errors.\n\n\nExtra options after a \n--\n on the command line will be passed to the\n\npy.test \nhttps://pytest.org/\n_ test runner. For example, to stop immediately\nafter the first failure:\n\n\n$ tox -- -x\n\n\n\nOr to only run the test \ntest_create_user\n in file \ntest_users.py\n:\n\n\n$ tox -- burlap/tests/functional_tests/test_users.py::test_create_user\n\n\n\nBy default, the py.test backend hides normal output. To see everything:\n\n\n$ tox -- -s burlap/tests/functional_tests/test_users.py::test_create_user\n\n\n\nNote: If tox ever gives you trouble, you can ask it to recreate its virtualenvs\nby using the \n-r\n (or \n--recreate\n) option. Alternatively, you can start\nover completely by removing the \n.tox\n directory.\n\n\nUsing py.test\n\n\nIf you want to use \npy.test\n directly, you will first need to install the test\ndependencies. You will also need to install burlap itself in \ndevelopment\nmode\n (also called \neditable mode\n):\n\n\n$ pip install pytest mock\n$ pip install -e .\n$ py.test\n\n\n\nUnit tests\n\n\nThe goal of the unit tests is to test the internal logic of burlap functions,\nwithout actually running shell commands on a target system.\n\n\nMost unit tests make use of the \nmock \nhttp://pypi.python.org/pypi/mock/\n_\nlibrary.\n\n\nFunctional tests\n\n\nThe goal of the functional tests is to test that burlap functions have the\nexpected effect when run against a real target system.\n\n\nFunctional tests are contained in the \nburlap/tests/functional_tests/\n folder.\n\n\nRequirements\n\n\nRunning functional tests requires \nVagrant \nhttps://vagrantup.com/\n and\n\nVirtualBox \nhttps://www.virtualbox.org\n to launch the virtual machines\nagainst which the tests will be run.\n\n\nIf Vagrant is not installed, the functional tests will be skipped automatically\nand pytest will show a warning message.\n\n\nTarget boxes\n\n\nThe default tox configuration will run the functional tests using both\nPython 2.6 and 2.7, against a specific list of vagrant boxes. These boxes\nwill be downloaded from Atlas (formerly Vagrant Cloud) when needed if\nthey're not already installed on your computer.\n\n\n\n\n\n\n\n\nTarget OS\n\n\nVagrant Box Name\n\n\n\n\n\n\n\n\n\n\ncentos_6_5\n\n\nhttps://atlas.hashicorp.com/chef/boxes/centos-6.5\n\n\n\n\n\n\ndebian_6\n\n\nhttps://atlas.hashicorp.com/chef/boxes/debian-6.0.10\n\n\n\n\n\n\ndebian_7\n\n\nhttps://atlas.hashicorp.com/chef/boxes/debian-7.8\n\n\n\n\n\n\ndebian_8\n\n\nhttps://atlas.hashicorp.com/debian/boxes/jessie64\n\n\n\n\n\n\nubuntu_12_04\n\n\nhttps://atlas.hashicorp.com/hashicorp/boxes/precise64\n\n\n\n\n\n\nubuntu_14_04\n\n\nhttps://atlas.hashicorp.com/ubuntu/boxes/trusty64\n\n\n\n\n\n\n\n\nA tox environment name is the combination of the Python version\n(either \npy26\n or \npy27\n) and a target operating system.\n\n\nYou can use \ntox -l\n to get the list of all test environments.\n\n\nYou can use the \n-e\n option to run tests in one or more specific\nenvironments. For example, you could run the tests using Python 2.7\nonly, against both Ubuntu 12.04 and 14.04 boxes ::\n\n\n$ tox -e py27-ubuntu_12_04,py27-ubuntu_14_04\n\n\n\nSkipping the functional tests\n\n\nTo run the unit tests only, you can use the \nnone\n target:\n\n\n$ tox -e py26-none,py27-none\n\n\n\nUsing a specific Vagrant box\n\n\nIf you want to run the tests with a specific Vagrant box, you can use\nthe \nBURLAP_TEST_BOX\n environment variable and the \nnone\n target::\n\n\n$ export BURLAP_TEST_BOX='mybox'\n$ tox -e py27-none\n\n\n\nUsing a specific Vagrant provider\n\n\nIf you want to run the tests with a specific Vagrant provider, you can use\nthe \nBURLAP_TEST_PROVIDER\n environment variable::\n\n\n$ export BURLAP_TEST_BOX='vmware_box'\n$ export BURLAP_TEST_PROVIDER='vmware_fusion'\n$ tox -e py27-none\n\n\n\nDebugging functional tests\n\n\nWhen you're working on a functional test, sometimes you'll want to manually inspect\nthe state of the Vagrant VM. To do that, you can prevent it from being destroyed\nat the end of the test run by using the \nBURLAP_TEST_REUSE_VM\n environment\nvariable:\n\n\n$ export BURLAP_TEST_REUSE_VM=1\n$ tox -e py27-ubuntu_14_04 -- -x -k apache\n$ cd burlap/tests/functional_tests\n$ vagrant ssh", 
            "title": "Tests"
        }, 
        {
            "location": "/tests/#tests", 
            "text": "", 
            "title": "Tests"
        }, 
        {
            "location": "/tests/#using-tox", 
            "text": "The preferred way to run tests is to use  tox  https://tox.readthedocs.org/en/latest/ _.\nIt will take care of everything and run the tests on all supported Python\nversions (each in its own virtualenv) and all target operating systems :  $ tox  Tox will also build the Sphinx documentation, so it will tell you about any\nreStructuredText syntax errors.  Extra options after a  --  on the command line will be passed to the py.test  https://pytest.org/ _ test runner. For example, to stop immediately\nafter the first failure:  $ tox -- -x  Or to only run the test  test_create_user  in file  test_users.py :  $ tox -- burlap/tests/functional_tests/test_users.py::test_create_user  By default, the py.test backend hides normal output. To see everything:  $ tox -- -s burlap/tests/functional_tests/test_users.py::test_create_user  Note: If tox ever gives you trouble, you can ask it to recreate its virtualenvs\nby using the  -r  (or  --recreate ) option. Alternatively, you can start\nover completely by removing the  .tox  directory.", 
            "title": "Using tox"
        }, 
        {
            "location": "/tests/#using-pytest", 
            "text": "If you want to use  py.test  directly, you will first need to install the test\ndependencies. You will also need to install burlap itself in  development\nmode  (also called  editable mode ):  $ pip install pytest mock\n$ pip install -e .\n$ py.test", 
            "title": "Using py.test"
        }, 
        {
            "location": "/tests/#unit-tests", 
            "text": "The goal of the unit tests is to test the internal logic of burlap functions,\nwithout actually running shell commands on a target system.  Most unit tests make use of the  mock  http://pypi.python.org/pypi/mock/ _\nlibrary.", 
            "title": "Unit tests"
        }, 
        {
            "location": "/tests/#functional-tests", 
            "text": "The goal of the functional tests is to test that burlap functions have the\nexpected effect when run against a real target system.  Functional tests are contained in the  burlap/tests/functional_tests/  folder.", 
            "title": "Functional tests"
        }, 
        {
            "location": "/tests/#requirements", 
            "text": "Running functional tests requires  Vagrant  https://vagrantup.com/  and VirtualBox  https://www.virtualbox.org  to launch the virtual machines\nagainst which the tests will be run.  If Vagrant is not installed, the functional tests will be skipped automatically\nand pytest will show a warning message.", 
            "title": "Requirements"
        }, 
        {
            "location": "/tests/#target-boxes", 
            "text": "The default tox configuration will run the functional tests using both\nPython 2.6 and 2.7, against a specific list of vagrant boxes. These boxes\nwill be downloaded from Atlas (formerly Vagrant Cloud) when needed if\nthey're not already installed on your computer.     Target OS  Vagrant Box Name      centos_6_5  https://atlas.hashicorp.com/chef/boxes/centos-6.5    debian_6  https://atlas.hashicorp.com/chef/boxes/debian-6.0.10    debian_7  https://atlas.hashicorp.com/chef/boxes/debian-7.8    debian_8  https://atlas.hashicorp.com/debian/boxes/jessie64    ubuntu_12_04  https://atlas.hashicorp.com/hashicorp/boxes/precise64    ubuntu_14_04  https://atlas.hashicorp.com/ubuntu/boxes/trusty64     A tox environment name is the combination of the Python version\n(either  py26  or  py27 ) and a target operating system.  You can use  tox -l  to get the list of all test environments.  You can use the  -e  option to run tests in one or more specific\nenvironments. For example, you could run the tests using Python 2.7\nonly, against both Ubuntu 12.04 and 14.04 boxes ::  $ tox -e py27-ubuntu_12_04,py27-ubuntu_14_04", 
            "title": "Target boxes"
        }, 
        {
            "location": "/tests/#skipping-the-functional-tests", 
            "text": "To run the unit tests only, you can use the  none  target:  $ tox -e py26-none,py27-none", 
            "title": "Skipping the functional tests"
        }, 
        {
            "location": "/tests/#using-a-specific-vagrant-box", 
            "text": "If you want to run the tests with a specific Vagrant box, you can use\nthe  BURLAP_TEST_BOX  environment variable and the  none  target::  $ export BURLAP_TEST_BOX='mybox'\n$ tox -e py27-none", 
            "title": "Using a specific Vagrant box"
        }, 
        {
            "location": "/tests/#using-a-specific-vagrant-provider", 
            "text": "If you want to run the tests with a specific Vagrant provider, you can use\nthe  BURLAP_TEST_PROVIDER  environment variable::  $ export BURLAP_TEST_BOX='vmware_box'\n$ export BURLAP_TEST_PROVIDER='vmware_fusion'\n$ tox -e py27-none", 
            "title": "Using a specific Vagrant provider"
        }, 
        {
            "location": "/tests/#debugging-functional-tests", 
            "text": "When you're working on a functional test, sometimes you'll want to manually inspect\nthe state of the Vagrant VM. To do that, you can prevent it from being destroyed\nat the end of the test run by using the  BURLAP_TEST_REUSE_VM  environment\nvariable:  $ export BURLAP_TEST_REUSE_VM=1\n$ tox -e py27-ubuntu_14_04 -- -x -k apache\n$ cd burlap/tests/functional_tests\n$ vagrant ssh", 
            "title": "Debugging functional tests"
        }
    ]
}